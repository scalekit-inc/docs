"use strict";(self.webpackChunkscalekit_docs=self.webpackChunkscalekit_docs||[]).push([[557],{11265:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"m2m/m2m-basics","title":"M2M authentication basics","description":"Understand the fundamentals of Machine-to-Machine (M2M) authentication and how it secures API access for non-human clients.","source":"@site/docs/m2m/m2m-basics.mdx","sourceDirName":"m2m","slug":"/m2m/m2m-basics","permalink":"/m2m/m2m-basics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"m2m-basics","title":"M2M authentication basics","sidebar_label":"M2M basics","description":"Understand the fundamentals of Machine-to-Machine (M2M) authentication and how it secures API access for non-human clients.","hide_table_of_contents":true},"sidebar":"m2mSidebar","previous":{"title":"M2M Quickstart","permalink":"/m2m/quickstart"},"next":{"title":"Authenticate with Scalekit API","permalink":"/m2m/authenticate-scalekit-api"}}');var s=i(74848),a=i(28453);const o={id:"m2m-basics",title:"M2M authentication basics",sidebar_label:"M2M basics",description:"Understand the fundamentals of Machine-to-Machine (M2M) authentication and how it secures API access for non-human clients.",hide_table_of_contents:!0},c=void 0,r={},l=[{value:"When do you need M2M auth?",id:"when-do-you-need-m2m-auth",level:2},{value:"How machine-to-machine (M2M) auth works",id:"how-machine-to-machine-m2m-auth-works",level:2},{value:"How Scalekit helps",id:"how-scalekit-helps",level:2},{value:"How Scalekit supports M2M auth",id:"how-scalekit-supports-m2m-auth",level:2},{value:"Key behavior and properties",id:"key-behavior-and-properties",level:2}];function h(e){const n={em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{SimpleCode:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("SimpleCode",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Machine-to-machine (M2M) authentication enables secure access between non-human clients and your APIs, without any traditional human involvement."}),"\n",(0,s.jsx)(n.p,{children:"These machine clients could be automated clients, or AI agents, third-party integrations, backend jobs, or internal services that need to perform tasks on behalf of organizations."}),"\n",(0,s.jsx)(n.p,{children:"There are two key benefits to organizations and platforms with a robust M2M authentication system:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Secure, credential-based"})," (client ID and client secret) ",(0,s.jsx)(n.strong,{children:"authentication for non-human clients"})," without exposing hardcoded secrets or using long-lived tokens."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Centralized management of machine identities"}),", enabling granular permissions, credential rotation across internal and external services."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This structured approach to M2M auth ensures that machine clients can be authenticated with the same rigour as human users. It ensures secure, scoped access to APIs, simplifies integration development, and aligns with enterprise authentication standards."}),"\n",(0,s.jsx)(n.h2,{id:"when-do-you-need-m2m-auth",children:"When do you need M2M auth?"}),"\n",(0,s.jsx)(n.p,{children:"You'll typically use M2M auth when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automated clients or AI agents need to make requests on behalf of users or organizations"}),"\n",(0,s.jsx)(n.li,{children:"External platforms or third-party integrations (like Zapier or Snowflake) interact with your API"}),"\n",(0,s.jsx)(n.li,{children:"Internal services or background jobs need to programmatically invoke your APIs"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In all these cases, there's no human user session involved, but the system still needs a secure way to authenticate the client and determine what access they should have."}),"\n",(0,s.jsx)(n.h2,{id:"how-machine-to-machine-m2m-auth-works",children:"How machine-to-machine (M2M) auth works"}),"\n",(0,s.jsx)(n.p,{children:"Machine-to-machine authentication typically follows the OAuth 2.0 client credentials flow. This is a standardized way for non-human clients to obtain access tokens without requiring user interaction."}),"\n",(0,s.jsx)(n.p,{children:"Let's start with how OAuth works:"}),"\n",(0,s.jsx)(n.p,{children:"OAuth 2.0 is an authorization framework that allows a client application to access protected resources on a resource server by presenting an access token. It delegates the authorization decision to a central authorization server, which issues access tokens after validating the client or user."}),"\n",(0,s.jsx)(n.p,{children:"The protocol defines several grant types, depending on the use case. For example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Client credentials flow"})," is used when one system (like an automated client or AI agent) wants to access another system's API"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authorization code flow"})," is used when a user authorizes a machine client to act on their behalf."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In the M2M use case, the client could be a backend service, AI agent, or integration. If it's an org-level or internal service client, it uses a ",(0,s.jsx)(t,{children:"client_id"})," and ",(0,s.jsx)(t,{children:"client_secret"})," to request an access token via the client credentials flow. For user-backed clients, a user first authorizes the client via the authorization code flow."]}),"\n",(0,s.jsx)(n.h2,{id:"how-scalekit-helps",children:"How Scalekit helps"}),"\n",(0,s.jsx)(n.p,{children:"Building secure M2M authentication from scratch can be complex, especially when dealing with token scoping, TTL, credential rotation, and validation."}),"\n",(0,s.jsx)(n.p,{children:"Scalekit handles these concerns out of the box with minimal setup. With just a few API calls or dashboard actions, you can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Register machine clients scoped to an organization"}),"\n",(0,s.jsx)(n.li,{children:"Generate and manage credentials with safe rotation"}),"\n",(0,s.jsxs)(n.li,{children:["Issue signed, short-lived JWTs with the right claims based on the  (",(0,s.jsx)(t,{children:"oid"}),", ",(0,s.jsx)(t,{children:"uid"}),", ",(0,s.jsx)(t,{children:"aud"}),", ",(0,s.jsx)(t,{children:"scopes"}),", etc.)"]}),"\n",(0,s.jsx)(n.li,{children:"Validate tokens locally in your API without needing to call back to Scalekit"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This allows you to enforce least-privilege access for automated clients without having to implement the OAuth flow or token lifecycle yourself."}),"\n",(0,s.jsx)(n.h2,{id:"how-scalekit-supports-m2m-auth",children:"How Scalekit supports M2M auth"}),"\n",(0,s.jsx)(n.p,{children:"Scalekit provides a purpose-built M2M auth system based on the OAuth 2.0 flow. The three types of machine clients are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Org-level clients:"})," Used when an automated client needs to access APIs on behalf of an organization. Tokens are scoped to a specific org (",(0,s.jsx)(t,{children:"oid"}),") and typically used in org-wide workflows. Read the M2M authentication quickstart to set up an org-level client."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User-level clients:"})," Used when a machine client is acting on behalf of a specific user. These tokens include a ",(0,s.jsx)(t,{children:"uid"})," (user ID) in addition to ",(0,s.jsx)(t,{children:"oid"})," and allow you to enforce user-contextual access. ",(0,s.jsx)(n.em,{children:"(Coming soon)"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Internal service clients:"})," Used for secure service-to-service communication between internal systems. These clients issue tokens with an ",(0,s.jsx)(t,{children:"aud"})," (audience) claim to enforce destination-specific access. They are ideal for microservices that need to talk to each other without org or user context. ",(0,s.jsx)(n.em,{children:"(Coming soon)"})]}),"\n"]}),"\n",(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"How M2M authentication works",src:i(20750).A+"",width:"4140",height:"3564"}),"\n",(0,s.jsx)("figcaption",{children:"M2M authentication secures machine-to-machine interactions with your API"})]})}),"\n",(0,s.jsx)(n.p,{children:"The high-level M2M auth flow looks like:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Register a machine client:"})," You create an M2M client in Scalekit for the machine that needs access to."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Generate credentials"}),": Scalekit issues a ",(0,s.jsx)(t,{children:"client_id"})," and ",(0,s.jsx)(t,{children:"client_secret"})," for that client. These are used to request access tokens."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Request an access token"}),": The machine client sends its credentials to Scalekit's ",(0,s.jsx)(t,{children:"/oauth/token"})," endpoint using the client credentials grant type."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Receive a signed JWT"}),": Scalekit validates the request and returns a short-lived, signed JWT that contains claims."]}),"\n",(0,s.jsx)(n.p,{children:"Depending on the type of client, when a token is issued, it contains information like:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Which organization it belongs to (",(0,s.jsx)(t,{children:"oid"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Which user it belongs to (",(0,s.jsx)(t,{children:"uid"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["What it's allowed to do (",(0,s.jsx)(t,{children:"scopes"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["How long it's valid for (",(0,s.jsx)(t,{children:"exp"}),", ",(0,s.jsx)(t,{children:"nbf"}),"), and"]}),"\n",(0,s.jsxs)(n.li,{children:["Which service it's intended for (",(0,s.jsx)(t,{children:"aud"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Each token is signed by Scalekit so your API can validate it locally without needing to call Scalekit. This improves performance and keeps your authorization flow resilient even if the auth server is briefly unavailable."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Make authenticated API calls"}),": The machine client sends this token in the ",(0,s.jsx)(t,{children:"Authorization"})," header when calling your API."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Your API validates the token"}),": Your API checks the token's signature and claims locally. No network call to Scalekit is needed."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach allows for a secure and programmatic authentication using short-lived, scoped tokens that can be revoked or rotated as needed."}),"\n",(0,s.jsx)(n.h2,{id:"key-behavior-and-properties",children:"Key behavior and properties"}),"\n",(0,s.jsx)(n.p,{children:"Tokens issued by Scalekit are designed to be secure by default and operationally smooth to manage over time:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Short-lived"}),": All tokens have a configurable TTL (default: 1 hour; minimum: 5 minutes) to reduce long-term risk."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Locally verifiable"}),": Tokens are signed JWTs that can be verified by your API without calling back to Scalekit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Supports rotation"}),": Each client can store up to five secrets at a time, making credential rotation seamless with no downtime."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Includes identity context"}),": Tokens contain claims like ",(0,s.jsx)(t,{children:"oid"})," (org ID), ",(0,s.jsx)(t,{children:"uid"})," (user ID), and ",(0,s.jsx)(t,{children:"aud"})," (audience) so you can enforce precise access."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scoped access"}),": Define fine-grained scopes to limit what a client is allowed to do."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These defaults ensure that tokens are short-lived, constrained in what they can do, and fully verifiable without external dependencies."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},20750:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/seq-hifi-03b90cf1227cf6f1f74c5c6ef98127eb.png"},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var t=i(96540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);